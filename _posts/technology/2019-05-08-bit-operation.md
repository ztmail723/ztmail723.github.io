---
layout: post
title:  用位操作实现整数加法、减法、乘法
date:   2019-05-08 10:00:00 +0800
categories: 技术文档
tag: 算法
---
什么是位运算
-------------------
详细可参考[wiki](https://en.wikipedia.org/wiki/Bitwise_operation)  

C语言中位操作(Bitwise operation)有以下六种：

	位运算符(Bitwise operators)

    ~ 按位取反(NOT)
	~0=1
	~1=0

	& 按位与(AND)
	0&0=0
	1&0=0
	0&1=0
	1&1=1

	| 按位或(OR)
	0|0=0
	0|1=1
	1|0=1
	1|1=1

	^ 按位异或(XOR)(相同为0，相异为1)
	0^0=0
	0^1=1
	1^0=1
	1~1=0

	算数移位(Arithmetic shift)

	<< 左移(left arithmetic shift)
	空缺位补0

	>> 右移(right arithmetic shift)
	正数空缺位补0，负数空缺位补1

举个例子，对于数字17，二进制下表示为00010001，而对于数字-4，二进制下表示为11111100（负数的补码为原码10000100除符号位取反加一），对其进行的按位运算操作如下(假设共有8bit存储单位)

     a  = 00010001 = 17
	 b  = 11111100 = -4
	~b  = 00000011 = 3
	a&b = 00010000 = 16
	a|b = 11111101 = -3
	a<<2= 01000100 = 68
	b>>1= 11111110 = -2

如何用位运算模拟加法
-------------------
由数字电路的知识我们知道，二进制补码可以把减法转换成加法。比如a-b的值我们可以表示为a+(-b)。所以，我们首先讨论如何用六种位运算模拟加法。  
首先针对每一位，我们如下四种可能

	0+0=0
	0+1=1
	1+0=1
	1+1=10

暂且不讨论相加是否有进位的情况，最后的表达式可以看做1+1=0。对于这个结果，是不是有种熟悉的感觉呢？

	0^0=0
	0^1=1
	1^0=1
	1~1=0

没错，与异或运算恰好对应。模拟a+b，似乎只要对a^b进行一些处理即可。而处理的关键在于【进位】。尝试将a和b进行异或吧！

	ID(87654321)
	   00010001 a
	 ^ 11111100 b
	 ------------
	   11101101 c

得到了c=11101101，那么我们再想想看进位操作如何进行。这个运算中，产生进位的是第5位，进上来的1加到了第6位上，相当于c加上00100000。那么接着进行异或运算吧！

	ID(87654321)
	   11101101 c
	 ^ 00100000 d
	 ------------
	   11001101 e

这一次发生进位的是在第6位，进上来的1加到了第7位上，相当于e加上01000000。那么我们继续运算下去

	ID(87654321)
	   11001101 e
	 ^ 01000000 f
	 ------------
	   10001101 g
	 ^ 10000000 h
	 ------------
	   00001101 i

这时再进位的数已经溢出了，整个过程结束。是不是发现了什么奥妙？每一次加法都是【异或得到的值】与【进位产生的值】的再次加法，直到【进位产生的值】为0时停止，显然，这可以用递归函数来描述。  
因而问题的关键就是如何获得【进位产生的值】。再来看一下之前的提出的四条基本加法准则

	0+0=0	进位0
	0+1=1	进位0
	1+0=1	进位0
	1+1=0	进位1

只有在参与运算的位都是1的情况下，才会有进位。你联想到了什么呢？

	0&0=0
	1&0=0
	0&1=0
	1&1=1

没错，按位与运算与这种情况恰好吻合，a&b得出的正是进位的状况。  
但是这还不够，a&b求出的是哪一位的运算会产生进位，但是进位应当是进到【下一位】，如何解决这个问题呢？  
这个很简单，用【左移】运算即可解决。
加法运算，用以下递归关系式即可解决

{% highlight c++%}
int add(int a,int b)
{
    return b==0?a:add(a^b,a&b<<1);
}    
{% endhighlight%}

(未完待续)
